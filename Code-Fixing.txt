1. Hardcoded database credentials (and duplicated credentials across classes)
- Problem
  - DB URL, user and password are hardcoded in DatabaseConnection and duplicated in Officer/Lecturer. Credentials in source = security risk and prevents configuration per environment.
- Resolution
  - Move credentials out of source: read from environment variables or a config file (application.properties). Update DatabaseConnection to read env vars with sensible default fallback. Remove hardcoded creds from Officer/Lecturer and stop passing credentials around — use DatabaseConnection.getConnection() everywhere.
- Conventional commit
  - fix(db): externalize database credentials to environment variables
- Issue title
  - Externalize DB credentials and remove hardcoded credentials from code
- Issue description
  - Move DB connection settings out of source code. Update DatabaseConnection to read JDBC_URL / JDBC_USER / JDBC_PASSWORD from environment variables (with safe defaults for dev). Remove hardcoded URL/user/password fields from Officer and Lecturer and update report output calls to use DatabaseConnection only. Acceptance criteria:
    - No JDBC credentials stored directly in any .java file.
    - DatabaseConnection.getConnection() uses env vars when present.
    - Officer/Lecturer compile and run using DatabaseConnection only

2. Plaintext password storage and authentication
- Problem
  - UserManager stores passwords in plaintext and compares them directly — severe security issue.
- Resolution
  - Store password hashes (bcrypt). When creating or changing a password, hash it. When authenticating, verify using bcrypt. Use a small bcrypt library (e.g., jBCrypt org.mindrot.jbcrypt.BCrypt). Update User to store hashedPassword (and remove public/plain field access). Update UserManager.addUser, modifyPassword and getUser accordingly.
- Conventional commit
  - feat(auth): add bcrypt password hashing and verification
- Issue title
  - Implement password hashing (bcrypt) and update authentication logic
- Issue description
  - Replace plaintext password handling with secure hashing using bcrypt. Update User class to hold a hashed password and change UserManager methods:
    - addUser(username, password, ...) must hash password before storing
    - modifyPassword must hash new password
    - getUser must verify the plain password against stored hash
    - Update any client code accordingly.
  - Acceptance criteria:
    - No plaintext passwords persisted in memory fields for long-term storage.
    - Authentication passes with correct password and fails with incorrect one.
    - Unit tests added for hashing and verification.

3. UserManager: duplicate usernames allowed and API lacks status returns
- Problem
  - addUser does not detect duplicate usernames and does not return success boolean. modifyUsername doesn't check for existence/uniqueness of new username. This leads to conflicting users and ambiguous admin flows.
- Resolution
  - Make addUser return boolean (success/fail). Before adding, check doesUserExist(username). modifyUsername should ensure newUsername isn't already used and should return boolean. Update all call sites to handle boolean return and show proper messages.
- Conventional commit
  - fix(user): prevent duplicate usernames and make add/modify return boolean
- Issue title
  - Prevent duplicate usernames and return status on add/modify operations
- Issue description
  - Update UserManager.addUser and modifyUsername to return boolean success status. addUser must check for existing username and refuse duplicates. modifyUsername must fail if new username is taken. Update UI flows (Admin.modifyUser, Admin.processAdminCommand, Officer/Lecturer client code) to handle returned status and inform user. Acceptance criteria:
    - Trying to create a username that already exists returns false and does not create a new user.
    - Attempt to rename to an existing username fails and returns false.
    - UI displays clear success/failure messages.