High-Risk Problems

1. Hardcoded database credentials (and duplicated credentials across classes)
- Problem
  - DB URL, user and password are hardcoded in DatabaseConnection and duplicated in Officer/Lecturer. Credentials in source = security risk and prevents configuration per environment.
- Resolution
  - Move credentials out of source: read from environment variables or a config file (application.properties). Update DatabaseConnection to read env vars with sensible default fallback. Remove hardcoded creds from Officer/Lecturer and stop passing credentials around — use DatabaseConnection.getConnection() everywhere.
- Conventional commit
  - fix(db): externalize database credentials to environment variables
- Issue title
  - Externalize DB credentials and remove hardcoded credentials from code
- Issue description
  - Move DB connection settings out of source code. Update DatabaseConnection to read JDBC_URL / JDBC_USER / JDBC_PASSWORD from environment variables (with safe defaults for dev). Remove hardcoded URL/user/password fields from Officer and Lecturer and update report output calls to use DatabaseConnection only. Acceptance criteria:
    - No JDBC credentials stored directly in any .java file.
    - DatabaseConnection.getConnection() uses env vars when present.
    - Officer/Lecturer compile and run using DatabaseConnection only

2. Plaintext password storage and authentication
- Problem
  - UserManager stores passwords in plaintext and compares them directly — severe security issue.
- Resolution
  - Store password hashes (bcrypt). When creating or changing a password, hash it. When authenticating, verify using bcrypt. Use a small bcrypt library (e.g., jBCrypt org.mindrot.jbcrypt.BCrypt). Update User to store hashedPassword (and remove public/plain field access). Update UserManager.addUser, modifyPassword and getUser accordingly.
- Conventional commit
  - feat(auth): add bcrypt password hashing and verification
- Issue title
  - Implement password hashing (bcrypt) and update authentication logic
- Issue description
  - Replace plaintext password handling with secure hashing using bcrypt. Update User class to hold a hashed password and change UserManager methods:
    - addUser(username, password, ...) must hash password before storing
    - modifyPassword must hash new password
    - getUser must verify the plain password against stored hash
    - Update any client code accordingly.
  - Acceptance criteria:
    - No plaintext passwords persisted in memory fields for long-term storage.
    - Authentication passes with correct password and fails with incorrect one.
    - Unit tests added for hashing and verification.

3. UserManager: duplicate usernames allowed and API lacks status returns
- Problem
  - addUser does not detect duplicate usernames and does not return success boolean. modifyUsername doesn't check for existence/uniqueness of new username. This leads to conflicting users and ambiguous admin flows.
- Resolution
  - Make addUser return boolean (success/fail). Before adding, check doesUserExist(username). modifyUsername should ensure newUsername isn't already used and should return boolean. Update all call sites to handle boolean return and show proper messages.
- Conventional commit
  - fix(user): prevent duplicate usernames and make add/modify return boolean
- Issue title
  - Prevent duplicate usernames and return status on add/modify operations
- Issue description
  - Update UserManager.addUser and modifyUsername to return boolean success status. addUser must check for existing username and refuse duplicates. modifyUsername must fail if new username is taken. Update UI flows (Admin.modifyUser, Admin.processAdminCommand, Officer/Lecturer client code) to handle returned status and inform user. Acceptance criteria:
    - Trying to create a username that already exists returns false and does not create a new user.
    - Attempt to rename to an existing username fails and returns false.
    - UI displays clear success/failure messages.

4. Faulty / non-portable SQL and ambiguous aliases in report queries
- Problem
  - Queries use expressions like SUM(sm.Enrolled = 0) (MySQL boolean-to-int trick), GROUP_CONCAT with conditional WHEN ... = 0 that may be logically inverted, and column aliases contain spaces / backticks. These queries are fragile, hard to read and may produce wrong aggregates.
- Resolution
  - Rewrite queries to be explicit and portable: use COUNT(CASE WHEN ... THEN 1 END) for counts, use GROUP_CONCAT(DISTINCT CASE WHEN ... THEN m.ModuleName END SEPARATOR '; ') with correct conditions, remove spaces in alias names (use ModuleName, EnrolledModules, etc.). Add unit tests or run queries against sample DB to validate results.
- Conventional commit
  - fix(sql): correct and sanitize report SQL queries for portability and clarity
- Issue title
Fix report SQL queries (aggregations and aliases) and validate results
- Issue description
  - Update StudentReportVariables, LecturerReportVariables and CourseReportVariables SQL strings to:
    - Use explicit COUNT(CASE WHEN ... THEN 1 END) constructs for counts
    - Correct conditional logic for which modules are "teaching" / "can teach"
    - Use safe column aliases (no spaces, no backticks)
    - Add a short SQL test (or sample data) to verify expected output for each report.
  - Acceptance criteria:
    - Queries return correct counts and module lists on sample data.
    - No query uses boolean-to-int tricks like SUM(expr = 0) or aliases with spaces.
    - Output columns map to ReportConstructor getters reliably.

Medium-Risk Problems

1. SQL alias / ResultSet column-name mismatch
- Problem
  - fetchStudentInfo reads ResultSet columns using labels that do not match SQL aliases (e.g., "Enrolled Modules", "Grades"); produces nulls.
- Resolution
  - Align ResultSet.getString(...) calls with SQL aliases or change SQL aliases to match getters. Use consistent names: Student, Programme, EnrolledModules, CompletedModulesAndGrades, ToRepeat.
- Conventional commit
  - fix(sql): align student report SQL aliases and ResultSet getters
- Issue title
  - Fix column aliases and getters in student report query and parser
- Issue description
  - Update StudentReportVariables.sql aliases and fetchStudentInfo to use consistent column labels. Ensure OutputStudent uses the same labels when writing headings. Acceptance:
    - StudentReportVariables.fetchStudentInfo returns non-null values for all fields on sample data.
    - OutputStudent prints correct values.

2. Lecturer & Course report SQL uses non-portable boolean-to-int tricks and ambiguous logic
- Problem
  - Queries use expressions like SUM(sm.Enrolled = 0) and CASE WHEN lm.IsTeaching = 0 THEN ... — fragile, non-portable and possibly inverted semantics.
- Resolution
  - Rewrite aggregates using COUNT(CASE WHEN ... THEN 1 END) and explicit conditions (IsTeaching = 1 means teaching). Remove aliases with spaces. Add unit test / sample data verification.
- Conventional commit
  - fix(sql): rewrite lecturer/course report queries to use explicit conditional aggregates
- Issue title
  - Replace boolean-to-int SQL expressions with COUNT(CASE WHEN ...) and fix logical conditions
- Issue description
  - Update LecturerReportVariables.sql and CourseReportVariables.sql to:
    - Use COUNT(CASE WHEN ... THEN 1 END) for counts
    - Confirm IsTeaching/CanTeach semantics and adjust conditions
    - Use consistent aliases (ModulesTeaching, NumberOfStudents, ModulesCanTeach)
    - Add a simple SQL test or sample data to validate counts
  - Acceptance:
    - Queries produce expected counts on sample DB.
    - No SUM(expr = 0) constructs remain.